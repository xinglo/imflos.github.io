(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.getVideoId = factory());
}(this, function () { 'use strict';

	var getSrc = function (input) {
		if (typeof input !== 'string') {
			throw new TypeError('get-src expected a string');
		}
		var re = /src="(.*?)"/gm;
		var url = re.exec(input);

		if (url && url.length >= 2) {
			return url[1];
		}
	};

	/**
	 * Strip away any parameters following `?` or `/` or '&'
	 * @param str
	 * @returns {String}
	 */
	function stripParameters(str) {
	  // Split parameters or split folder separator
	  if (str.indexOf('?') > -1) {
	    return str.split('?')[0];
	  }

	  if (str.indexOf('/') > -1) {
	    return str.split('/')[0];
	  }

	  if (str.indexOf('&') > -1) {
	    return str.split('&')[0];
	  }

	  return str;
	}

	/**
	 * Get the Youtube Video id.
	 * @param {string} youtubeStr - the url from which you want to extract the id
	 * @returns {string|undefined}
	 */

	function youtube(youtubeStr) {
	  var str = youtubeStr; // remove time hash at the end of the string

	  str = str.replace(/#t=.*$/, ''); // shortcode

	  var shortcode = /youtube:\/\/|https?:\/\/youtu\.be\/|http:\/\/y2u\.be\//g;

	  if (shortcode.test(str)) {
	    var shortcodeid = str.split(shortcode)[1];
	    return stripParameters(shortcodeid);
	  } // /v/ or /vi/


	  var inlinev = /\/v\/|\/vi\//g;

	  if (inlinev.test(str)) {
	    var inlineid = str.split(inlinev)[1];
	    return stripParameters(inlineid);
	  } // v= or vi=


	  var parameterv = /v=|vi=/g;

	  if (parameterv.test(str)) {
	    var arr = str.split(parameterv);
	    return stripParameters(arr[1].split('&')[0]);
	  } // v= or vi=


	  var parameterwebp = /\/an_webp\//g;

	  if (parameterwebp.test(str)) {
	    var webp = str.split(parameterwebp)[1];
	    return stripParameters(webp);
	  } // embed


	  var embedreg = /\/embed\//g;

	  if (embedreg.test(str)) {
	    var embedid = str.split(embedreg)[1];
	    return stripParameters(embedid);
	  } // ignore /user/username pattern


	  var usernamereg = /\/user\/([a-zA-Z0-9]*)$/g;

	  if (usernamereg.test(str)) {
	    return undefined;
	  } // user


	  var userreg = /\/user\/(?!.*videos)/g;

	  if (userreg.test(str)) {
	    var elements = str.split('/');
	    return stripParameters(elements.pop());
	  } // attribution_link


	  var attrreg = /\/attribution_link\?.*v%3D([^%&]*)(%26|&|$)/;

	  if (attrreg.test(str)) {
	    return stripParameters(str.match(attrreg)[1]);
	  }

	  return undefined;
	}

	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	function _iterableToArrayLimit(arr, i) {
	  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	/**
	 * Get the vimeo id.
	 * @param {string} vimeoStr - the url from which you want to extract the id
	 * @returns {string|undefined}
	 */
	function vimeo(vimeoStr) {
	  var str = vimeoStr;

	  if (str.indexOf('#') > -1) {
	    var _str$split = str.split('#');

	    var _str$split2 = _slicedToArray(_str$split, 1);

	    str = _str$split2[0];
	  }

	  if (str.indexOf('?') > -1 && str.indexOf('clip_id=') === -1) {
	    var _str$split3 = str.split('?');

	    var _str$split4 = _slicedToArray(_str$split3, 1);

	    str = _str$split4[0];
	  }

	  var id;
	  var arr;
	  var primary = /https?:\/\/vimeo\.com\/([0-9]+)/;
	  var matches = primary.exec(str);

	  if (matches && matches[1]) {
	    return matches[1];
	  }

	  var vimeoPipe = ['https?://player.vimeo.com/video/[0-9]+$', 'https?://vimeo.com/channels', 'groups', 'album'].join('|');
	  var vimeoRegex = new RegExp(vimeoPipe, 'gim');

	  if (vimeoRegex.test(str)) {
	    arr = str.split('/');

	    if (arr && arr.length) {
	      id = arr.pop();
	    }
	  } else if (/clip_id=/gim.test(str)) {
	    arr = str.split('clip_id=');

	    if (arr && arr.length) {
	      var _arr$1$split = arr[1].split('&');

	      var _arr$1$split2 = _slicedToArray(_arr$1$split, 1);

	      id = _arr$1$split2[0];
	    }
	  }

	  return id;
	}

	/**
	 * Get the vine id.
	 * @param {string} str - the url from which you want to extract the id
	 * @returns {string|undefined}
	 */
	function vine(str) {
	  var regex = /https:\/\/vine\.co\/v\/([a-zA-Z0-9]*)\/?/;
	  var matches = regex.exec(str);
	  return matches && matches[1];
	}

	/**
	 * Get the VideoPress id.
	 * @param {string} str - the url from which you want to extract the id
	 * @returns {string|undefined}
	 */
	function videopress(str) {
	  var idRegex;

	  if (str.indexOf('embed') > -1) {
	    idRegex = /embed\/(\w{8})/;
	    return str.match(idRegex)[1];
	  }

	  idRegex = /\/v\/(\w{8})/;
	  var match = str.match(idRegex);

	  if (match && match.length > 0) {
	    return str.match(idRegex)[1];
	  }

	  return undefined;
	}

	/**
	 * Get the id and service from a video url.
	 * @param {String} videoStr - the url from which you want to extract the id
	 * @returns {Object}
	 */

	function getVideoId(videoStr) {
	  if (typeof videoStr !== 'string') {
	    throw new TypeError('get-video-id expects a string');
	  }

	  var str = videoStr;

	  if (/<iframe/gi.test(str)) {
	    str = getSrc(str);
	  } // remove surrounding whitespaces or linefeeds


	  str = str.trim(); // remove the '-nocookie' flag from youtube urls

	  str = str.replace('-nocookie', ''); // remove any leading `www.`

	  str = str.replace('/www.', '/');
	  var metadata = {
	    id: null,
	    service: null
	  }; // Try to handle google redirection uri

	  if (/\/\/google/.test(str)) {
	    // Find the redirection uri
	    var matches = str.match(/url=([^&]+)&/); // Decode the found uri and replace current url string - continue with final link

	    if (matches) {
	      // JavaScript can get encoded URI
	      str = decodeURIComponent(matches[1]);
	    }
	  }

	  if (/youtube|youtu\.be|y2u\.be|i.ytimg\./.test(str)) {
	    metadata = {
	      id: youtube(str),
	      service: 'youtube'
	    };
	  } else if (/vimeo/.test(str)) {
	    metadata = {
	      id: vimeo(str),
	      service: 'vimeo'
	    };
	  } else if (/vine/.test(str)) {
	    metadata = {
	      id: vine(str),
	      service: 'vine'
	    };
	  } else if (/videopress/.test(str)) {
	    metadata = {
	      id: videopress(str),
	      service: 'videopress'
	    };
	  }

	  return metadata;
	}

	return getVideoId;

}));
//# sourceMappingURL=get-video-id.js.map
